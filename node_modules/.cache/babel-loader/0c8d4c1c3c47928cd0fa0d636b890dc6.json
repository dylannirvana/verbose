{"ast":null,"code":"/**\n * Packery Item Element\n**/\n(function (window) {\n  'use strict'; // -------------------------- Item -------------------------- //\n\n  function itemDefinition(getStyleProperty, Outlayer, Rect) {\n    var transformProperty = getStyleProperty('transform'); // sub-class Item\n\n    var Item = function PackeryItem() {\n      Outlayer.Item.apply(this, arguments);\n    };\n\n    Item.prototype = new Outlayer.Item();\n    var protoCreate = Item.prototype._create;\n\n    Item.prototype._create = function () {\n      // call default _create logic\n      protoCreate.call(this);\n      this.rect = new Rect(); // rect used for placing, in drag or Packery.fit()\n\n      this.placeRect = new Rect();\n    }; // -------------------------- drag -------------------------- //\n\n\n    Item.prototype.dragStart = function () {\n      this.getPosition();\n      this.removeTransitionStyles(); // remove transform property from transition\n\n      if (this.isTransitioning && transformProperty) {\n        this.element.style[transformProperty] = 'none';\n      }\n\n      this.getSize(); // create place rect, used for position when dragged then dropped\n      // or when positioning\n\n      this.isPlacing = true;\n      this.needsPositioning = false;\n      this.positionPlaceRect(this.position.x, this.position.y);\n      this.isTransitioning = false;\n      this.didDrag = false;\n    };\n    /**\n     * handle item when it is dragged\n     * @param {Number} x - horizontal position of dragged item\n     * @param {Number} y - vertical position of dragged item\n     */\n\n\n    Item.prototype.dragMove = function (x, y) {\n      this.didDrag = true;\n      var packerySize = this.layout.size;\n      x -= packerySize.paddingLeft;\n      y -= packerySize.paddingTop;\n      this.positionPlaceRect(x, y);\n    };\n\n    Item.prototype.dragStop = function () {\n      this.getPosition();\n      var isDiffX = this.position.x !== this.placeRect.x;\n      var isDiffY = this.position.y !== this.placeRect.y; // set post-drag positioning flag\n\n      this.needsPositioning = isDiffX || isDiffY; // reset flag\n\n      this.didDrag = false;\n    }; // -------------------------- placing -------------------------- //\n\n    /**\n     * position a rect that will occupy space in the packer\n     * @param {Number} x\n     * @param {Number} y\n     * @param {Boolean} isMaxYContained\n     */\n\n\n    Item.prototype.positionPlaceRect = function (x, y, isMaxYOpen) {\n      this.placeRect.x = this.getPlaceRectCoord(x, true);\n      this.placeRect.y = this.getPlaceRectCoord(y, false, isMaxYOpen);\n    };\n    /**\n     * get x/y coordinate for place rect\n     * @param {Number} coord - x or y\n     * @param {Boolean} isX\n     * @param {Boolean} isMaxOpen - does not limit value to outer bound\n     * @returns {Number} coord - processed x or y\n     */\n\n\n    Item.prototype.getPlaceRectCoord = function (coord, isX, isMaxOpen) {\n      var measure = isX ? 'Width' : 'Height';\n      var size = this.size['outer' + measure];\n      var segment = this.layout[isX ? 'columnWidth' : 'rowHeight'];\n      var parentSize = this.layout.size['inner' + measure]; // additional parentSize calculations for Y\n\n      if (!isX) {\n        parentSize = Math.max(parentSize, this.layout.maxY); // prevent gutter from bumping up height when non-vertical grid\n\n        if (!this.layout.rowHeight) {\n          parentSize -= this.layout.gutter;\n        }\n      }\n\n      var max;\n\n      if (segment) {\n        segment += this.layout.gutter; // allow for last column to reach the edge\n\n        parentSize += isX ? this.layout.gutter : 0; // snap to closest segment\n\n        coord = Math.round(coord / segment); // contain to outer bound\n        // contain non-growing bound, allow growing bound to grow\n\n        var mathMethod;\n\n        if (this.layout.options.isHorizontal) {\n          mathMethod = !isX ? 'floor' : 'ceil';\n        } else {\n          mathMethod = isX ? 'floor' : 'ceil';\n        }\n\n        var maxSegments = Math[mathMethod](parentSize / segment);\n        maxSegments -= Math.ceil(size / segment);\n        max = maxSegments;\n      } else {\n        max = parentSize - size;\n      }\n\n      coord = isMaxOpen ? coord : Math.min(coord, max);\n      coord *= segment || 1;\n      return Math.max(0, coord);\n    };\n\n    Item.prototype.copyPlaceRectPosition = function () {\n      this.rect.x = this.placeRect.x;\n      this.rect.y = this.placeRect.y;\n    }; // -----  ----- //\n    // remove element from DOM\n\n\n    Item.prototype.removeElem = function () {\n      this.element.parentNode.removeChild(this.element); // add space back to packer\n\n      this.layout.packer.addSpace(this.rect);\n      this.emitEvent('remove', [this]);\n    }; // -----  ----- //\n\n\n    return Item;\n  } // -------------------------- transport -------------------------- //\n\n\n  if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = itemDefinition(require('desandro-get-style-property'), require('outlayer'), require('./rect'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['get-style-property/get-style-property', 'outlayer/outlayer', './rect'], itemDefinition);\n  } else {\n    // browser global\n    window.Packery.Item = itemDefinition(window.getStyleProperty, window.Outlayer, window.Packery.Rect);\n  }\n})(window);","map":null,"metadata":{},"sourceType":"script"}