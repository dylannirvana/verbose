{"ast":null,"code":"/*!\n * Draggabilly v2.2.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['get-size/get-size', 'unidragger/unidragger'], function (getSize, Unidragger) {\n      return factory(window, getSize, Unidragger);\n    });\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('get-size'), require('unidragger'));\n  } else {\n    // browser global\n    window.Draggabilly = factory(window, window.getSize, window.Unidragger);\n  }\n})(window, function factory(window, getSize, Unidragger) {\n  'use strict'; // -------------------------- helpers & variables -------------------------- //\n  // extend objects\n\n  function extend(a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n\n    return a;\n  }\n\n  function noop() {}\n\n  var jQuery = window.jQuery; // --------------------------  -------------------------- //\n\n  function Draggabilly(element, options) {\n    // querySelector if string\n    this.element = typeof element == 'string' ? document.querySelector(element) : element;\n\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    } // options\n\n\n    this.options = extend({}, this.constructor.defaults);\n    this.option(options);\n\n    this._create();\n  } // inherit Unidragger methods\n\n\n  var proto = Draggabilly.prototype = Object.create(Unidragger.prototype);\n  Draggabilly.defaults = {};\n  /**\n   * set options\n   * @param {Object} opts\n   */\n\n  proto.option = function (opts) {\n    extend(this.options, opts);\n  }; // css position values that don't need to be set\n\n\n  var positionValues = {\n    relative: true,\n    absolute: true,\n    fixed: true\n  };\n\n  proto._create = function () {\n    // properties\n    this.position = {};\n\n    this._getPosition();\n\n    this.startPoint = {\n      x: 0,\n      y: 0\n    };\n    this.dragPoint = {\n      x: 0,\n      y: 0\n    };\n    this.startPosition = extend({}, this.position); // set relative positioning\n\n    var style = getComputedStyle(this.element);\n\n    if (!positionValues[style.position]) {\n      this.element.style.position = 'relative';\n    } // events, bridge jQuery events from vanilla\n\n\n    this.on('pointerDown', this.onPointerDown);\n    this.on('pointerMove', this.onPointerMove);\n    this.on('pointerUp', this.onPointerUp);\n    this.enable();\n    this.setHandles();\n  };\n  /**\n   * set this.handles and bind start events to 'em\n   */\n\n\n  proto.setHandles = function () {\n    this.handles = this.options.handle ? this.element.querySelectorAll(this.options.handle) : [this.element];\n    this.bindHandles();\n  };\n  /**\n   * emits events via EvEmitter and jQuery events\n   * @param {String} type - name of event\n   * @param {Event} event - original event\n   * @param {Array} args - extra arguments\n   */\n\n\n  proto.dispatchEvent = function (type, event, args) {\n    var emitArgs = [event].concat(args);\n    this.emitEvent(type, emitArgs);\n    this.dispatchJQueryEvent(type, event, args);\n  };\n\n  proto.dispatchJQueryEvent = function (type, event, args) {\n    var jQuery = window.jQuery; // trigger jQuery event\n\n    if (!jQuery || !this.$element) {\n      return;\n    } // create jQuery event\n\n\n    var $event = jQuery.Event(event);\n    $event.type = type;\n    this.$element.trigger($event, args);\n  }; // -------------------------- position -------------------------- //\n  // get x/y position from style\n\n\n  proto._getPosition = function () {\n    var style = getComputedStyle(this.element);\n\n    var x = this._getPositionCoord(style.left, 'width');\n\n    var y = this._getPositionCoord(style.top, 'height'); // clean up 'auto' or other non-integer values\n\n\n    this.position.x = isNaN(x) ? 0 : x;\n    this.position.y = isNaN(y) ? 0 : y;\n\n    this._addTransformPosition(style);\n  };\n\n  proto._getPositionCoord = function (styleSide, measure) {\n    if (styleSide.indexOf('%') != -1) {\n      // convert percent into pixel for Safari, #75\n      var parentSize = getSize(this.element.parentNode); // prevent not-in-DOM element throwing bug, #131\n\n      return !parentSize ? 0 : parseFloat(styleSide) / 100 * parentSize[measure];\n    }\n\n    return parseInt(styleSide, 10);\n  }; // add transform: translate( x, y ) to position\n\n\n  proto._addTransformPosition = function (style) {\n    var transform = style.transform; // bail out if value is 'none'\n\n    if (transform.indexOf('matrix') !== 0) {\n      return;\n    } // split matrix(1, 0, 0, 1, x, y)\n\n\n    var matrixValues = transform.split(','); // translate X value is in 12th or 4th position\n\n    var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;\n    var translateX = parseInt(matrixValues[xIndex], 10); // translate Y value is in 13th or 5th position\n\n    var translateY = parseInt(matrixValues[xIndex + 1], 10);\n    this.position.x += translateX;\n    this.position.y += translateY;\n  }; // -------------------------- events -------------------------- //\n\n\n  proto.onPointerDown = function (event, pointer) {\n    this.element.classList.add('is-pointer-down');\n    this.dispatchJQueryEvent('pointerDown', event, [pointer]);\n  };\n  /**\n   * drag start\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n\n\n  proto.dragStart = function (event, pointer) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    this._getPosition();\n\n    this.measureContainment(); // position _when_ drag began\n\n    this.startPosition.x = this.position.x;\n    this.startPosition.y = this.position.y; // reset left/top style\n\n    this.setLeftTop();\n    this.dragPoint.x = 0;\n    this.dragPoint.y = 0;\n    this.element.classList.add('is-dragging');\n    this.dispatchEvent('dragStart', event, [pointer]); // start animation\n\n    this.animate();\n  };\n\n  proto.measureContainment = function () {\n    var container = this.getContainer();\n\n    if (!container) {\n      return;\n    }\n\n    var elemSize = getSize(this.element);\n    var containerSize = getSize(container);\n    var elemRect = this.element.getBoundingClientRect();\n    var containerRect = container.getBoundingClientRect();\n    var borderSizeX = containerSize.borderLeftWidth + containerSize.borderRightWidth;\n    var borderSizeY = containerSize.borderTopWidth + containerSize.borderBottomWidth;\n    var position = this.relativeStartPosition = {\n      x: elemRect.left - (containerRect.left + containerSize.borderLeftWidth),\n      y: elemRect.top - (containerRect.top + containerSize.borderTopWidth)\n    };\n    this.containSize = {\n      width: containerSize.width - borderSizeX - position.x - elemSize.width,\n      height: containerSize.height - borderSizeY - position.y - elemSize.height\n    };\n  };\n\n  proto.getContainer = function () {\n    var containment = this.options.containment;\n\n    if (!containment) {\n      return;\n    }\n\n    var isElement = containment instanceof HTMLElement; // use as element\n\n    if (isElement) {\n      return containment;\n    } // querySelector if string\n\n\n    if (typeof containment == 'string') {\n      return document.querySelector(containment);\n    } // fallback to parent element\n\n\n    return this.element.parentNode;\n  }; // ----- move event ----- //\n\n\n  proto.onPointerMove = function (event, pointer, moveVector) {\n    this.dispatchJQueryEvent('pointerMove', event, [pointer, moveVector]);\n  };\n  /**\n   * drag move\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n\n\n  proto.dragMove = function (event, pointer, moveVector) {\n    if (!this.isEnabled) {\n      return;\n    }\n\n    var dragX = moveVector.x;\n    var dragY = moveVector.y;\n    var grid = this.options.grid;\n    var gridX = grid && grid[0];\n    var gridY = grid && grid[1];\n    dragX = applyGrid(dragX, gridX);\n    dragY = applyGrid(dragY, gridY);\n    dragX = this.containDrag('x', dragX, gridX);\n    dragY = this.containDrag('y', dragY, gridY); // constrain to axis\n\n    dragX = this.options.axis == 'y' ? 0 : dragX;\n    dragY = this.options.axis == 'x' ? 0 : dragY;\n    this.position.x = this.startPosition.x + dragX;\n    this.position.y = this.startPosition.y + dragY; // set dragPoint properties\n\n    this.dragPoint.x = dragX;\n    this.dragPoint.y = dragY;\n    this.dispatchEvent('dragMove', event, [pointer, moveVector]);\n  };\n\n  function applyGrid(value, grid, method) {\n    method = method || 'round';\n    return grid ? Math[method](value / grid) * grid : value;\n  }\n\n  proto.containDrag = function (axis, drag, grid) {\n    if (!this.options.containment) {\n      return drag;\n    }\n\n    var measure = axis == 'x' ? 'width' : 'height';\n    var rel = this.relativeStartPosition[axis];\n    var min = applyGrid(-rel, grid, 'ceil');\n    var max = this.containSize[measure];\n    max = applyGrid(max, grid, 'floor');\n    return Math.max(min, Math.min(max, drag));\n  }; // ----- end event ----- //\n\n  /**\n   * pointer up\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n\n\n  proto.onPointerUp = function (event, pointer) {\n    this.element.classList.remove('is-pointer-down');\n    this.dispatchJQueryEvent('pointerUp', event, [pointer]);\n  };\n  /**\n   * drag end\n   * @param {Event} event\n   * @param {Event or Touch} pointer\n   */\n\n\n  proto.dragEnd = function (event, pointer) {\n    if (!this.isEnabled) {\n      return;\n    } // use top left position when complete\n\n\n    this.element.style.transform = '';\n    this.setLeftTop();\n    this.element.classList.remove('is-dragging');\n    this.dispatchEvent('dragEnd', event, [pointer]);\n  }; // -------------------------- animation -------------------------- //\n\n\n  proto.animate = function () {\n    // only render and animate if dragging\n    if (!this.isDragging) {\n      return;\n    }\n\n    this.positionDrag();\n\n    var _this = this;\n\n    requestAnimationFrame(function animateFrame() {\n      _this.animate();\n    });\n  }; // left/top positioning\n\n\n  proto.setLeftTop = function () {\n    this.element.style.left = this.position.x + 'px';\n    this.element.style.top = this.position.y + 'px';\n  };\n\n  proto.positionDrag = function () {\n    this.element.style.transform = 'translate3d( ' + this.dragPoint.x + 'px, ' + this.dragPoint.y + 'px, 0)';\n  }; // ----- staticClick ----- //\n\n\n  proto.staticClick = function (event, pointer) {\n    this.dispatchEvent('staticClick', event, [pointer]);\n  }; // ----- methods ----- //\n\n  /**\n   * @param {Number} x\n   * @param {Number} y\n   */\n\n\n  proto.setPosition = function (x, y) {\n    this.position.x = x;\n    this.position.y = y;\n    this.setLeftTop();\n  };\n\n  proto.enable = function () {\n    this.isEnabled = true;\n  };\n\n  proto.disable = function () {\n    this.isEnabled = false;\n\n    if (this.isDragging) {\n      this.dragEnd();\n    }\n  };\n\n  proto.destroy = function () {\n    this.disable(); // reset styles\n\n    this.element.style.transform = '';\n    this.element.style.left = '';\n    this.element.style.top = '';\n    this.element.style.position = ''; // unbind handles\n\n    this.unbindHandles(); // remove jQuery data\n\n    if (this.$element) {\n      this.$element.removeData('draggabilly');\n    }\n  }; // ----- jQuery bridget ----- //\n  // required for jQuery bridget\n\n\n  proto._init = noop;\n\n  if (jQuery && jQuery.bridget) {\n    jQuery.bridget('draggabilly', Draggabilly);\n  } // -----  ----- //\n\n\n  return Draggabilly;\n});","map":null,"metadata":{},"sourceType":"script"}