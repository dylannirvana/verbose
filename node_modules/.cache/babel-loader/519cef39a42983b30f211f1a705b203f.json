{"ast":null,"code":"/*!\n * Packery v1.3.0\n * bin-packing layout library\n * http://packery.metafizzy.co\n *\n * Commercial use requires one-time purchase of a commercial license\n * http://packery.metafizzy.co/license.html\n *\n * Non-commercial use is licensed under the GPL v3 License\n *\n * Copyright 2014 Metafizzy\n */\n(function (window) {\n  'use strict'; // -------------------------- Packery -------------------------- //\n  // used for AMD definition and requires\n\n  function packeryDefinition(classie, getSize, Outlayer, Rect, Packer, Item) {\n    // create an Outlayer layout class\n    var Packery = Outlayer.create('packery');\n    Packery.Item = Item;\n\n    Packery.prototype._create = function () {\n      // call super\n      Outlayer.prototype._create.call(this); // initial properties\n\n\n      this.packer = new Packer(); // Left over from v1.0\n\n      this.stamp(this.options.stamped); // create drag handlers\n\n      var _this = this;\n\n      this.handleDraggabilly = {\n        dragStart: function dragStart(draggie) {\n          _this.itemDragStart(draggie.element);\n        },\n        dragMove: function dragMove(draggie) {\n          _this.itemDragMove(draggie.element, draggie.position.x, draggie.position.y);\n        },\n        dragEnd: function dragEnd(draggie) {\n          _this.itemDragEnd(draggie.element);\n        }\n      };\n      this.handleUIDraggable = {\n        start: function handleUIDraggableStart(event) {\n          _this.itemDragStart(event.currentTarget);\n        },\n        drag: function handleUIDraggableDrag(event, ui) {\n          _this.itemDragMove(event.currentTarget, ui.position.left, ui.position.top);\n        },\n        stop: function handleUIDraggableStop(event) {\n          _this.itemDragEnd(event.currentTarget);\n        }\n      };\n    }; // ----- init & layout ----- //\n\n    /**\n     * logic before any new layout\n     */\n\n\n    Packery.prototype._resetLayout = function () {\n      this.getSize();\n\n      this._getMeasurements(); // reset packer\n\n\n      var packer = this.packer; // packer settings, if horizontal or vertical\n\n      if (this.options.isHorizontal) {\n        packer.width = Number.POSITIVE_INFINITY;\n        packer.height = this.size.innerHeight + this.gutter;\n        packer.sortDirection = 'rightwardTopToBottom';\n      } else {\n        packer.width = this.size.innerWidth + this.gutter;\n        packer.height = Number.POSITIVE_INFINITY;\n        packer.sortDirection = 'downwardLeftToRight';\n      }\n\n      packer.reset(); // layout\n\n      this.maxY = 0;\n      this.maxX = 0;\n    };\n    /**\n     * update columnWidth, rowHeight, & gutter\n     * @private\n     */\n\n\n    Packery.prototype._getMeasurements = function () {\n      this._getMeasurement('columnWidth', 'width');\n\n      this._getMeasurement('rowHeight', 'height');\n\n      this._getMeasurement('gutter', 'width');\n    };\n\n    Packery.prototype._getItemLayoutPosition = function (item) {\n      this._packItem(item);\n\n      return item.rect;\n    };\n    /**\n     * layout item in packer\n     * @param {Packery.Item} item\n     */\n\n\n    Packery.prototype._packItem = function (item) {\n      this._setRectSize(item.element, item.rect); // pack the rect in the packer\n\n\n      this.packer.pack(item.rect);\n\n      this._setMaxXY(item.rect);\n    };\n    /**\n     * set max X and Y value, for size of container\n     * @param {Packery.Rect} rect\n     * @private\n     */\n\n\n    Packery.prototype._setMaxXY = function (rect) {\n      this.maxX = Math.max(rect.x + rect.width, this.maxX);\n      this.maxY = Math.max(rect.y + rect.height, this.maxY);\n    };\n    /**\n     * set the width and height of a rect, applying columnWidth and rowHeight\n     * @param {Element} elem\n     * @param {Packery.Rect} rect\n     */\n\n\n    Packery.prototype._setRectSize = function (elem, rect) {\n      var size = getSize(elem);\n      var w = size.outerWidth;\n      var h = size.outerHeight; // size for columnWidth and rowHeight, if available\n      // only check if size is non-zero, #177\n\n      if (w || h) {\n        var colW = this.columnWidth + this.gutter;\n        var rowH = this.rowHeight + this.gutter;\n        w = this.columnWidth ? Math.ceil(w / colW) * colW : w + this.gutter;\n        h = this.rowHeight ? Math.ceil(h / rowH) * rowH : h + this.gutter;\n      } // rect must fit in packer\n\n\n      rect.width = Math.min(w, this.packer.width);\n      rect.height = Math.min(h, this.packer.height);\n    };\n\n    Packery.prototype._getContainerSize = function () {\n      if (this.options.isHorizontal) {\n        return {\n          width: this.maxX - this.gutter\n        };\n      } else {\n        return {\n          height: this.maxY - this.gutter\n        };\n      }\n    }; // -------------------------- stamp -------------------------- //\n\n    /**\n     * makes space for element\n     * @param {Element} elem\n     */\n\n\n    Packery.prototype._manageStamp = function (elem) {\n      var item = this.getItem(elem);\n      var rect;\n\n      if (item && item.isPlacing) {\n        rect = item.placeRect;\n      } else {\n        var offset = this._getElementOffset(elem);\n\n        rect = new Rect({\n          x: this.options.isOriginLeft ? offset.left : offset.right,\n          y: this.options.isOriginTop ? offset.top : offset.bottom\n        });\n      }\n\n      this._setRectSize(elem, rect); // save its space in the packer\n\n\n      this.packer.placed(rect);\n\n      this._setMaxXY(rect);\n    }; // -------------------------- methods -------------------------- //\n\n\n    function verticalSorter(a, b) {\n      return a.position.y - b.position.y || a.position.x - b.position.x;\n    }\n\n    function horizontalSorter(a, b) {\n      return a.position.x - b.position.x || a.position.y - b.position.y;\n    }\n\n    Packery.prototype.sortItemsByPosition = function () {\n      var sorter = this.options.isHorizontal ? horizontalSorter : verticalSorter;\n      this.items.sort(sorter);\n    };\n    /**\n     * Fit item element in its current position\n     * Packery will position elements around it\n     * useful for expanding elements\n     *\n     * @param {Element} elem\n     * @param {Number} x - horizontal destination position, optional\n     * @param {Number} y - vertical destination position, optional\n     */\n\n\n    Packery.prototype.fit = function (elem, x, y) {\n      var item = this.getItem(elem);\n\n      if (!item) {\n        return;\n      } // prepare internal properties\n\n\n      this._getMeasurements(); // stamp item to get it out of layout\n\n\n      this.stamp(item.element); // required for positionPlaceRect\n\n      item.getSize(); // set placing flag\n\n      item.isPlacing = true; // fall back to current position for fitting\n\n      x = x === undefined ? item.rect.x : x;\n      y = y === undefined ? item.rect.y : y; // position it best at its destination\n\n      item.positionPlaceRect(x, y, true);\n\n      this._bindFitEvents(item);\n\n      item.moveTo(item.placeRect.x, item.placeRect.y); // layout everything else\n\n      this.layout(); // return back to regularly scheduled programming\n\n      this.unstamp(item.element);\n      this.sortItemsByPosition(); // un set placing flag, back to normal\n\n      item.isPlacing = false; // copy place rect position\n\n      item.copyPlaceRectPosition();\n    };\n    /**\n     * emit event when item is fit and other items are laid out\n     * @param {Packery.Item} item\n     * @private\n     */\n\n\n    Packery.prototype._bindFitEvents = function (item) {\n      var _this = this;\n\n      var ticks = 0;\n\n      function tick() {\n        ticks++;\n\n        if (ticks !== 2) {\n          return;\n        }\n\n        _this.emitEvent('fitComplete', [_this, item]);\n      } // when item is laid out\n\n\n      item.on('layout', function () {\n        tick();\n        return true;\n      }); // when all items are laid out\n\n      this.on('layoutComplete', function () {\n        tick();\n        return true;\n      });\n    }; // -------------------------- resize -------------------------- //\n    // debounced, layout on resize\n\n\n    Packery.prototype.resize = function () {\n      // don't trigger if size did not change\n      var size = getSize(this.element); // check that this.size and size are there\n      // IE8 triggers resize on body size change, so they might not be\n\n      var hasSizes = this.size && size;\n      var innerSize = this.options.isHorizontal ? 'innerHeight' : 'innerWidth';\n\n      if (hasSizes && size[innerSize] === this.size[innerSize]) {\n        return;\n      }\n\n      this.layout();\n    }; // -------------------------- drag -------------------------- //\n\n    /**\n     * handle an item drag start event\n     * @param {Element} elem\n     */\n\n\n    Packery.prototype.itemDragStart = function (elem) {\n      this.stamp(elem);\n      var item = this.getItem(elem);\n\n      if (item) {\n        item.dragStart();\n      }\n    };\n    /**\n     * handle an item drag move event\n     * @param {Element} elem\n     * @param {Number} x - horizontal change in position\n     * @param {Number} y - vertical change in position\n     */\n\n\n    Packery.prototype.itemDragMove = function (elem, x, y) {\n      var item = this.getItem(elem);\n\n      if (item) {\n        item.dragMove(x, y);\n      } // debounce\n\n\n      var _this = this; // debounce triggering layout\n\n\n      function delayed() {\n        _this.layout();\n\n        delete _this.dragTimeout;\n      }\n\n      this.clearDragTimeout();\n      this.dragTimeout = setTimeout(delayed, 40);\n    };\n\n    Packery.prototype.clearDragTimeout = function () {\n      if (this.dragTimeout) {\n        clearTimeout(this.dragTimeout);\n      }\n    };\n    /**\n     * handle an item drag end event\n     * @param {Element} elem\n     */\n\n\n    Packery.prototype.itemDragEnd = function (elem) {\n      var item = this.getItem(elem);\n      var itemDidDrag;\n\n      if (item) {\n        itemDidDrag = item.didDrag;\n        item.dragStop();\n      } // if elem didn't move, or if it doesn't need positioning\n      // unignore and unstamp and call it a day\n\n\n      if (!item || !itemDidDrag && !item.needsPositioning) {\n        this.unstamp(elem);\n        return;\n      } // procced with dragged item\n\n\n      classie.add(item.element, 'is-positioning-post-drag'); // save this var, as it could get reset in dragStart\n\n      var onLayoutComplete = this._getDragEndLayoutComplete(elem, item);\n\n      if (item.needsPositioning) {\n        item.on('layout', onLayoutComplete);\n        item.moveTo(item.placeRect.x, item.placeRect.y);\n      } else if (item) {\n        // item didn't need placement\n        item.copyPlaceRectPosition();\n      }\n\n      this.clearDragTimeout();\n      this.on('layoutComplete', onLayoutComplete);\n      this.layout();\n    };\n    /**\n     * get drag end callback\n     * @param {Element} elem\n     * @param {Packery.Item} item\n     * @returns {Function} onLayoutComplete\n     */\n\n\n    Packery.prototype._getDragEndLayoutComplete = function (elem, item) {\n      var itemNeedsPositioning = item && item.needsPositioning;\n      var completeCount = 0;\n      var asyncCount = itemNeedsPositioning ? 2 : 1;\n\n      var _this = this;\n\n      return function onLayoutComplete() {\n        completeCount++; // don't proceed if not complete\n\n        if (completeCount !== asyncCount) {\n          return true;\n        } // reset item\n\n\n        if (item) {\n          classie.remove(item.element, 'is-positioning-post-drag');\n          item.isPlacing = false;\n          item.copyPlaceRectPosition();\n        }\n\n        _this.unstamp(elem); // only sort when item moved\n\n\n        _this.sortItemsByPosition(); // emit item drag event now that everything is done\n\n\n        if (itemNeedsPositioning) {\n          _this.emitEvent('dragItemPositioned', [_this, item]);\n        } // listen once\n\n\n        return true;\n      };\n    };\n    /**\n     * binds Draggabilly events\n     * @param {Draggabilly} draggie\n     */\n\n\n    Packery.prototype.bindDraggabillyEvents = function (draggie) {\n      draggie.on('dragStart', this.handleDraggabilly.dragStart);\n      draggie.on('dragMove', this.handleDraggabilly.dragMove);\n      draggie.on('dragEnd', this.handleDraggabilly.dragEnd);\n    };\n    /**\n     * binds jQuery UI Draggable events\n     * @param {jQuery} $elems\n     */\n\n\n    Packery.prototype.bindUIDraggableEvents = function ($elems) {\n      $elems.on('dragstart', this.handleUIDraggable.start).on('drag', this.handleUIDraggable.drag).on('dragstop', this.handleUIDraggable.stop);\n    };\n\n    Packery.Rect = Rect;\n    Packery.Packer = Packer;\n    return Packery;\n  } // -------------------------- transport -------------------------- //\n\n\n  if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = packeryDefinition(require('classie'), require('get-size'), require('outlayer'), require('./rect'), require('./packer'), require('./item'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['classie/classie', 'get-size/get-size', 'outlayer/outlayer', './rect', './packer', './item'], packeryDefinition);\n  } else {\n    // browser global\n    window.Packery = packeryDefinition(window.classie, window.getSize, window.Outlayer, window.Packery.Rect, window.Packery.Packer, window.Packery.Item);\n  }\n})(window);","map":null,"metadata":{},"sourceType":"script"}