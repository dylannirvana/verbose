{"ast":null,"code":"/**\n * Outlayer Item\n */\n(function (window) {\n  'use strict';\n\n  if (!window) return; // ----- get style ----- //\n\n  var getComputedStyle = window.getComputedStyle;\n  var getStyle = getComputedStyle ? function (elem) {\n    return getComputedStyle(elem, null);\n  } : function (elem) {\n    return elem.currentStyle;\n  }; // extend objects\n\n  function extend(a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n\n    return a;\n  }\n\n  function isEmptyObj(obj) {\n    for (var prop in obj) {\n      return false;\n    }\n\n    prop = null;\n    return true;\n  } // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\n\n\n  function toDash(str) {\n    return str.replace(/([A-Z])/g, function ($1) {\n      return '-' + $1.toLowerCase();\n    });\n  } // -------------------------- Outlayer definition -------------------------- //\n\n\n  function outlayerItemDefinition(EventEmitter, getSize, getStyleProperty) {\n    // -------------------------- CSS3 support -------------------------- //\n    var transitionProperty = getStyleProperty('transition');\n    var transformProperty = getStyleProperty('transform');\n    var supportsCSS3 = transitionProperty && transformProperty;\n    var is3d = !!getStyleProperty('perspective');\n    var transitionEndEvent = {\n      WebkitTransition: 'webkitTransitionEnd',\n      MozTransition: 'transitionend',\n      OTransition: 'otransitionend',\n      transition: 'transitionend'\n    }[transitionProperty]; // properties that could have vendor prefix\n\n    var prefixableProperties = ['transform', 'transition', 'transitionDuration', 'transitionProperty']; // cache all vendor properties\n\n    var vendorProperties = function () {\n      var cache = {};\n\n      for (var i = 0, len = prefixableProperties.length; i < len; i++) {\n        var prop = prefixableProperties[i];\n        var supportedProp = getStyleProperty(prop);\n\n        if (supportedProp && supportedProp !== prop) {\n          cache[prop] = supportedProp;\n        }\n      }\n\n      return cache;\n    }(); // -------------------------- Item -------------------------- //\n\n\n    function Item(element, layout) {\n      if (!element) {\n        return;\n      }\n\n      this.element = element; // parent layout class, i.e. Masonry, Isotope, or Packery\n\n      this.layout = layout;\n      this.position = {\n        x: 0,\n        y: 0\n      };\n\n      this._create();\n    } // inherit EventEmitter\n\n\n    extend(Item.prototype, EventEmitter.prototype);\n\n    Item.prototype._create = function () {\n      // transition objects\n      this._transn = {\n        ingProperties: {},\n        clean: {},\n        onEnd: {}\n      };\n      this.css({\n        position: 'absolute'\n      });\n    }; // trigger specified handler for event type\n\n\n    Item.prototype.handleEvent = function (event) {\n      var method = 'on' + event.type;\n\n      if (this[method]) {\n        this[method](event);\n      }\n    };\n\n    Item.prototype.getSize = function () {\n      this.size = getSize(this.element);\n    };\n    /**\n     * apply CSS styles to element\n     * @param {Object} style\n     */\n\n\n    Item.prototype.css = function (style) {\n      var elemStyle = this.element.style;\n\n      for (var prop in style) {\n        // use vendor property if available\n        var supportedProp = vendorProperties[prop] || prop;\n        elemStyle[supportedProp] = style[prop];\n      }\n    }; // measure position, and sets it\n\n\n    Item.prototype.getPosition = function () {\n      var style = getStyle(this.element);\n      var layoutOptions = this.layout.options;\n      var isOriginLeft = layoutOptions.isOriginLeft;\n      var isOriginTop = layoutOptions.isOriginTop;\n      var x = parseInt(style[isOriginLeft ? 'left' : 'right'], 10);\n      var y = parseInt(style[isOriginTop ? 'top' : 'bottom'], 10); // clean up 'auto' or other non-integer values\n\n      x = isNaN(x) ? 0 : x;\n      y = isNaN(y) ? 0 : y; // remove padding from measurement\n\n      var layoutSize = this.layout.size;\n      x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n      y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n      this.position.x = x;\n      this.position.y = y;\n    }; // set settled position, apply padding\n\n\n    Item.prototype.layoutPosition = function () {\n      var layoutSize = this.layout.size;\n      var layoutOptions = this.layout.options;\n      var style = {};\n\n      if (layoutOptions.isOriginLeft) {\n        style.left = this.position.x + layoutSize.paddingLeft + 'px'; // reset other property\n\n        style.right = '';\n      } else {\n        style.right = this.position.x + layoutSize.paddingRight + 'px';\n        style.left = '';\n      }\n\n      if (layoutOptions.isOriginTop) {\n        style.top = this.position.y + layoutSize.paddingTop + 'px';\n        style.bottom = '';\n      } else {\n        style.bottom = this.position.y + layoutSize.paddingBottom + 'px';\n        style.top = '';\n      }\n\n      this.css(style);\n      this.emitEvent('layout', [this]);\n    }; // transform translate function\n\n\n    var translate = is3d ? function (x, y) {\n      return 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n    } : function (x, y) {\n      return 'translate(' + x + 'px, ' + y + 'px)';\n    };\n\n    Item.prototype._transitionTo = function (x, y) {\n      this.getPosition(); // get current x & y from top/left\n\n      var curX = this.position.x;\n      var curY = this.position.y;\n      var compareX = parseInt(x, 10);\n      var compareY = parseInt(y, 10);\n      var didNotMove = compareX === this.position.x && compareY === this.position.y; // save end position\n\n      this.setPosition(x, y); // if did not move and not transitioning, just go to layout\n\n      if (didNotMove && !this.isTransitioning) {\n        this.layoutPosition();\n        return;\n      }\n\n      var transX = x - curX;\n      var transY = y - curY;\n      var transitionStyle = {}; // flip cooridinates if origin on right or bottom\n\n      var layoutOptions = this.layout.options;\n      transX = layoutOptions.isOriginLeft ? transX : -transX;\n      transY = layoutOptions.isOriginTop ? transY : -transY;\n      transitionStyle.transform = translate(transX, transY);\n      this.transition({\n        to: transitionStyle,\n        onTransitionEnd: {\n          transform: this.layoutPosition\n        },\n        isCleaning: true\n      });\n    }; // non transition + transform support\n\n\n    Item.prototype.goTo = function (x, y) {\n      this.setPosition(x, y);\n      this.layoutPosition();\n    }; // use transition and transforms if supported\n\n\n    Item.prototype.moveTo = supportsCSS3 ? Item.prototype._transitionTo : Item.prototype.goTo;\n\n    Item.prototype.setPosition = function (x, y) {\n      this.position.x = parseInt(x, 10);\n      this.position.y = parseInt(y, 10);\n    }; // ----- transition ----- //\n\n    /**\n     * @param {Object} style - CSS\n     * @param {Function} onTransitionEnd\n     */\n    // non transition, just trigger callback\n\n\n    Item.prototype._nonTransition = function (args) {\n      this.css(args.to);\n\n      if (args.isCleaning) {\n        this._removeStyles(args.to);\n      }\n\n      for (var prop in args.onTransitionEnd) {\n        args.onTransitionEnd[prop].call(this);\n      }\n    };\n    /**\n     * proper transition\n     * @param {Object} args - arguments\n     *   @param {Object} to - style to transition to\n     *   @param {Object} from - style to start transition from\n     *   @param {Boolean} isCleaning - removes transition styles after transition\n     *   @param {Function} onTransitionEnd - callback\n     */\n\n\n    Item.prototype._transition = function (args) {\n      // redirect to nonTransition if no transition duration\n      if (!parseFloat(this.layout.options.transitionDuration)) {\n        this._nonTransition(args);\n\n        return;\n      }\n\n      var _transition = this._transn; // keep track of onTransitionEnd callback by css property\n\n      for (var prop in args.onTransitionEnd) {\n        _transition.onEnd[prop] = args.onTransitionEnd[prop];\n      } // keep track of properties that are transitioning\n\n\n      for (prop in args.to) {\n        _transition.ingProperties[prop] = true; // keep track of properties to clean up when transition is done\n\n        if (args.isCleaning) {\n          _transition.clean[prop] = true;\n        }\n      } // set from styles\n\n\n      if (args.from) {\n        this.css(args.from); // force redraw. http://blog.alexmaccaw.com/css-transitions\n\n        var h = this.element.offsetHeight; // hack for JSHint to hush about unused var\n\n        h = null;\n      } // enable transition\n\n\n      this.enableTransition(args.to); // set styles that are transitioning\n\n      this.css(args.to);\n      this.isTransitioning = true;\n    };\n\n    var itemTransitionProperties = transformProperty && toDash(transformProperty) + ',opacity';\n\n    Item.prototype.enableTransition = function ()\n    /* style */\n    {\n      // only enable if not already transitioning\n      // bug in IE10 were re-setting transition style will prevent\n      // transitionend event from triggering\n      if (this.isTransitioning) {\n        return;\n      } // make transition: foo, bar, baz from style object\n      // TODO uncomment this bit when IE10 bug is resolved\n      // var transitionValue = [];\n      // for ( var prop in style ) {\n      //   // dash-ify camelCased properties like WebkitTransition\n      //   transitionValue.push( toDash( prop ) );\n      // }\n      // enable transition styles\n      // HACK always enable transform,opacity for IE10\n\n\n      this.css({\n        transitionProperty: itemTransitionProperties,\n        transitionDuration: this.layout.options.transitionDuration\n      }); // listen for transition end event\n\n      this.element.addEventListener(transitionEndEvent, this, false);\n    };\n\n    Item.prototype.transition = Item.prototype[transitionProperty ? '_transition' : '_nonTransition']; // ----- events ----- //\n\n    Item.prototype.onwebkitTransitionEnd = function (event) {\n      this.ontransitionend(event);\n    };\n\n    Item.prototype.onotransitionend = function (event) {\n      this.ontransitionend(event);\n    }; // properties that I munge to make my life easier\n\n\n    var dashedVendorProperties = {\n      '-webkit-transform': 'transform',\n      '-moz-transform': 'transform',\n      '-o-transform': 'transform'\n    };\n\n    Item.prototype.ontransitionend = function (event) {\n      // disregard bubbled events from children\n      if (event.target !== this.element) {\n        return;\n      }\n\n      var _transition = this._transn; // get property name of transitioned property, convert to prefix-free\n\n      var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName; // remove property that has completed transitioning\n\n      delete _transition.ingProperties[propertyName]; // check if any properties are still transitioning\n\n      if (isEmptyObj(_transition.ingProperties)) {\n        // all properties have completed transitioning\n        this.disableTransition();\n      } // clean style\n\n\n      if (propertyName in _transition.clean) {\n        // clean up style\n        this.element.style[event.propertyName] = '';\n        delete _transition.clean[propertyName];\n      } // trigger onTransitionEnd callback\n\n\n      if (propertyName in _transition.onEnd) {\n        var onTransitionEnd = _transition.onEnd[propertyName];\n        onTransitionEnd.call(this);\n        delete _transition.onEnd[propertyName];\n      }\n\n      this.emitEvent('transitionEnd', [this]);\n    };\n\n    Item.prototype.disableTransition = function () {\n      this.removeTransitionStyles();\n      this.element.removeEventListener(transitionEndEvent, this, false);\n      this.isTransitioning = false;\n    };\n    /**\n     * removes style property from element\n     * @param {Object} style\n    **/\n\n\n    Item.prototype._removeStyles = function (style) {\n      // clean up transition styles\n      var cleanStyle = {};\n\n      for (var prop in style) {\n        cleanStyle[prop] = '';\n      }\n\n      this.css(cleanStyle);\n    };\n\n    var cleanTransitionStyle = {\n      transitionProperty: '',\n      transitionDuration: ''\n    };\n\n    Item.prototype.removeTransitionStyles = function () {\n      // remove transition\n      this.css(cleanTransitionStyle);\n    }; // ----- show/hide/remove ----- //\n    // remove element from DOM\n\n\n    Item.prototype.removeElem = function () {\n      this.element.parentNode.removeChild(this.element);\n      this.emitEvent('remove', [this]);\n    };\n\n    Item.prototype.remove = function () {\n      // just remove element if no transition support or no transition\n      if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n        this.removeElem();\n        return;\n      } // start transition\n\n\n      var _this = this;\n\n      this.on('transitionEnd', function () {\n        _this.removeElem();\n\n        return true; // bind once\n      });\n      this.hide();\n    };\n\n    Item.prototype.reveal = function () {\n      delete this.isHidden; // remove display: none\n\n      this.css({\n        display: ''\n      });\n      var options = this.layout.options;\n      this.transition({\n        from: options.hiddenStyle,\n        to: options.visibleStyle,\n        isCleaning: true\n      });\n    };\n\n    Item.prototype.hide = function () {\n      // set flag\n      this.isHidden = true; // remove display: none\n\n      this.css({\n        display: ''\n      });\n      var options = this.layout.options;\n      this.transition({\n        from: options.visibleStyle,\n        to: options.hiddenStyle,\n        // keep hidden stuff hidden\n        isCleaning: true,\n        onTransitionEnd: {\n          opacity: function opacity() {\n            // check if still hidden\n            // during transition, item may have been un-hidden\n            if (this.isHidden) {\n              this.css({\n                display: 'none'\n              });\n            }\n          }\n        }\n      });\n    };\n\n    Item.prototype.destroy = function () {\n      this.css({\n        position: '',\n        left: '',\n        right: '',\n        top: '',\n        bottom: '',\n        transition: '',\n        transform: ''\n      });\n    };\n\n    return Item;\n  } // -------------------------- transport -------------------------- //\n\n\n  if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = outlayerItemDefinition(require('eventemitter'), require('get-size'), require('desandro-get-style-property'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['eventEmitter/EventEmitter', 'get-size/get-size', 'get-style-property/get-style-property'], outlayerItemDefinition);\n  } else {\n    // browser global\n    window.Outlayer = {};\n    window.Outlayer.Item = outlayerItemDefinition(window.EventEmitter, window.getSize, window.getStyleProperty);\n  }\n})(typeof window !== 'undefined' ? window : null);","map":null,"metadata":{},"sourceType":"script"}