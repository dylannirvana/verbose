{"ast":null,"code":"/*!\n * Outlayer v1.2.0\n * the brains and guts of a layout library\n * MIT license\n */\n(function (window) {\n  'use strict';\n\n  if (!window) return; // ----- vars ----- //\n\n  var document = window.document;\n  var console = window.console;\n  var jQuery = window.jQuery;\n\n  var noop = function noop() {}; // -------------------------- helpers -------------------------- //\n  // extend objects\n\n\n  function extend(a, b) {\n    for (var prop in b) {\n      a[prop] = b[prop];\n    }\n\n    return a;\n  }\n\n  var objToString = Object.prototype.toString;\n\n  function isArray(obj) {\n    return objToString.call(obj) === '[object Array]';\n  } // turn element or nodeList into an array\n\n\n  function makeArray(obj) {\n    var ary = [];\n\n    if (isArray(obj)) {\n      // use object if already an array\n      ary = obj;\n    } else if (obj && typeof obj.length === 'number') {\n      // convert nodeList to array\n      for (var i = 0, len = obj.length; i < len; i++) {\n        ary.push(obj[i]);\n      }\n    } else {\n      // array of single index\n      ary.push(obj);\n    }\n\n    return ary;\n  } // http://stackoverflow.com/a/384380/182183\n\n\n  var isElement = typeof HTMLElement === 'function' || typeof HTMLElement === 'object' ? function isElementDOM2(obj) {\n    return obj instanceof HTMLElement;\n  } : function isElementQuirky(obj) {\n    return obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';\n  }; // index of helper cause IE8\n\n  var indexOf = Array.prototype.indexOf ? function (ary, obj) {\n    return ary.indexOf(obj);\n  } : function (ary, obj) {\n    for (var i = 0, len = ary.length; i < len; i++) {\n      if (ary[i] === obj) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  function removeFrom(obj, ary) {\n    var index = indexOf(ary, obj);\n\n    if (index !== -1) {\n      ary.splice(index, 1);\n    }\n  } // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\n\n\n  function toDashed(str) {\n    return str.replace(/(.)([A-Z])/g, function (match, $1, $2) {\n      return $1 + '-' + $2;\n    }).toLowerCase();\n  }\n\n  function outlayerDefinition(eventie, docReady, EventEmitter, getSize, matchesSelector, Item) {\n    // -------------------------- Outlayer -------------------------- //\n    // globally unique identifiers\n    var GUID = 0; // internal store of all Outlayer intances\n\n    var instances = {};\n    /**\n     * @param {Element, String} element\n     * @param {Object} options\n     * @constructor\n     */\n\n    function Outlayer(element, options) {\n      // use element as selector string\n      if (typeof element === 'string') {\n        element = document.querySelector(element);\n      } // bail out if not proper element\n\n\n      if (!element || !isElement(element)) {\n        if (console) {\n          console.error('Bad ' + this.constructor.namespace + ' element: ' + element);\n        }\n\n        return;\n      }\n\n      this.element = element; // options\n\n      this.options = extend({}, this.constructor.defaults);\n      this.option(options); // add id for Outlayer.getFromElement\n\n      var id = ++GUID;\n      this.element.outlayerGUID = id; // expando\n\n      instances[id] = this; // associate via id\n      // kick it off\n\n      this._create();\n\n      if (this.options.isInitLayout) {\n        this.layout();\n      }\n    } // settings are for internal use only\n\n\n    Outlayer.namespace = 'outlayer';\n    Outlayer.Item = Item; // default options\n\n    Outlayer.defaults = {\n      containerStyle: {\n        position: 'relative'\n      },\n      isInitLayout: true,\n      isOriginLeft: true,\n      isOriginTop: true,\n      isResizeBound: true,\n      isResizingContainer: true,\n      // item options\n      transitionDuration: '0.4s',\n      hiddenStyle: {\n        opacity: 0,\n        transform: 'scale(0.001)'\n      },\n      visibleStyle: {\n        opacity: 1,\n        transform: 'scale(1)'\n      }\n    }; // inherit EventEmitter\n\n    extend(Outlayer.prototype, EventEmitter.prototype);\n    /**\n     * set options\n     * @param {Object} opts\n     */\n\n    Outlayer.prototype.option = function (opts) {\n      extend(this.options, opts);\n    };\n\n    Outlayer.prototype._create = function () {\n      // get items from children\n      this.reloadItems(); // elements that affect layout, but are not laid out\n\n      this.stamps = [];\n      this.stamp(this.options.stamp); // set container style\n\n      extend(this.element.style, this.options.containerStyle); // bind resize method\n\n      if (this.options.isResizeBound) {\n        this.bindResize();\n      }\n    }; // goes through all children again and gets bricks in proper order\n\n\n    Outlayer.prototype.reloadItems = function () {\n      // collection of item elements\n      this.items = this._itemize(this.element.children);\n    };\n    /**\n     * turn elements into Outlayer.Items to be used in layout\n     * @param {Array or NodeList or HTMLElement} elems\n     * @returns {Array} items - collection of new Outlayer Items\n     */\n\n\n    Outlayer.prototype._itemize = function (elems) {\n      var itemElems = this._filterFindItemElements(elems);\n\n      var Item = this.constructor.Item; // create new Outlayer Items for collection\n\n      var items = [];\n\n      for (var i = 0, len = itemElems.length; i < len; i++) {\n        var elem = itemElems[i];\n        var item = new Item(elem, this);\n        items.push(item);\n      }\n\n      return items;\n    };\n    /**\n     * get item elements to be used in layout\n     * @param {Array or NodeList or HTMLElement} elems\n     * @returns {Array} items - item elements\n     */\n\n\n    Outlayer.prototype._filterFindItemElements = function (elems) {\n      // make array of elems\n      elems = makeArray(elems);\n      var itemSelector = this.options.itemSelector;\n      var itemElems = [];\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        var elem = elems[i]; // check that elem is an actual element\n\n        if (!isElement(elem)) {\n          continue;\n        } // filter & find items if we have an item selector\n\n\n        if (itemSelector) {\n          // filter siblings\n          if (matchesSelector(elem, itemSelector)) {\n            itemElems.push(elem);\n          } // find children\n\n\n          var childElems = elem.querySelectorAll(itemSelector); // concat childElems to filterFound array\n\n          for (var j = 0, jLen = childElems.length; j < jLen; j++) {\n            itemElems.push(childElems[j]);\n          }\n        } else {\n          itemElems.push(elem);\n        }\n      }\n\n      return itemElems;\n    };\n    /**\n     * getter method for getting item elements\n     * @returns {Array} elems - collection of item elements\n     */\n\n\n    Outlayer.prototype.getItemElements = function () {\n      var elems = [];\n\n      for (var i = 0, len = this.items.length; i < len; i++) {\n        elems.push(this.items[i].element);\n      }\n\n      return elems;\n    }; // ----- init & layout ----- //\n\n    /**\n     * lays out all items\n     */\n\n\n    Outlayer.prototype.layout = function () {\n      this._resetLayout();\n\n      this._manageStamps(); // don't animate first layout\n\n\n      var isInstant = this.options.isLayoutInstant !== undefined ? this.options.isLayoutInstant : !this._isLayoutInited;\n      this.layoutItems(this.items, isInstant); // flag for initalized\n\n      this._isLayoutInited = true;\n    }; // _init is alias for layout\n\n\n    Outlayer.prototype._init = Outlayer.prototype.layout;\n    /**\n     * logic before any new layout\n     */\n\n    Outlayer.prototype._resetLayout = function () {\n      this.getSize();\n    };\n\n    Outlayer.prototype.getSize = function () {\n      this.size = getSize(this.element);\n    };\n    /**\n     * get measurement from option, for columnWidth, rowHeight, gutter\n     * if option is String -> get element from selector string, & get size of element\n     * if option is Element -> get size of element\n     * else use option as a number\n     *\n     * @param {String} measurement\n     * @param {String} size - width or height\n     * @private\n     */\n\n\n    Outlayer.prototype._getMeasurement = function (measurement, size) {\n      var option = this.options[measurement];\n      var elem;\n\n      if (!option) {\n        // default to 0\n        this[measurement] = 0;\n      } else {\n        // use option as an element\n        if (typeof option === 'string') {\n          elem = this.element.querySelector(option);\n        } else if (isElement(option)) {\n          elem = option;\n        } // use size of element, if element\n\n\n        this[measurement] = elem ? getSize(elem)[size] : option;\n      }\n    };\n    /**\n     * layout a collection of item elements\n     * @api public\n     */\n\n\n    Outlayer.prototype.layoutItems = function (items, isInstant) {\n      items = this._getItemsForLayout(items);\n\n      this._layoutItems(items, isInstant);\n\n      this._postLayout();\n    };\n    /**\n     * get the items to be laid out\n     * you may want to skip over some items\n     * @param {Array} items\n     * @returns {Array} items\n     */\n\n\n    Outlayer.prototype._getItemsForLayout = function (items) {\n      var layoutItems = [];\n\n      for (var i = 0, len = items.length; i < len; i++) {\n        var item = items[i];\n\n        if (!item.isIgnored) {\n          layoutItems.push(item);\n        }\n      }\n\n      return layoutItems;\n    };\n    /**\n     * layout items\n     * @param {Array} items\n     * @param {Boolean} isInstant\n     */\n\n\n    Outlayer.prototype._layoutItems = function (items, isInstant) {\n      var _this = this;\n\n      function onItemsLayout() {\n        _this.emitEvent('layoutComplete', [_this, items]);\n      }\n\n      if (!items || !items.length) {\n        // no items, emit event with empty array\n        onItemsLayout();\n        return;\n      } // emit layoutComplete when done\n\n\n      this._itemsOn(items, 'layout', onItemsLayout);\n\n      var queue = [];\n\n      for (var i = 0, len = items.length; i < len; i++) {\n        var item = items[i]; // get x/y object from method\n\n        var position = this._getItemLayoutPosition(item); // enqueue\n\n\n        position.item = item;\n        position.isInstant = isInstant || item.isLayoutInstant;\n        queue.push(position);\n      }\n\n      this._processLayoutQueue(queue);\n    };\n    /**\n     * get item layout position\n     * @param {Outlayer.Item} item\n     * @returns {Object} x and y position\n     */\n\n\n    Outlayer.prototype._getItemLayoutPosition = function ()\n    /* item */\n    {\n      return {\n        x: 0,\n        y: 0\n      };\n    };\n    /**\n     * iterate over array and position each item\n     * Reason being - separating this logic prevents 'layout invalidation'\n     * thx @paul_irish\n     * @param {Array} queue\n     */\n\n\n    Outlayer.prototype._processLayoutQueue = function (queue) {\n      for (var i = 0, len = queue.length; i < len; i++) {\n        var obj = queue[i];\n\n        this._positionItem(obj.item, obj.x, obj.y, obj.isInstant);\n      }\n    };\n    /**\n     * Sets position of item in DOM\n     * @param {Outlayer.Item} item\n     * @param {Number} x - horizontal position\n     * @param {Number} y - vertical position\n     * @param {Boolean} isInstant - disables transitions\n     */\n\n\n    Outlayer.prototype._positionItem = function (item, x, y, isInstant) {\n      if (isInstant) {\n        // if not transition, just set CSS\n        item.goTo(x, y);\n      } else {\n        item.moveTo(x, y);\n      }\n    };\n    /**\n     * Any logic you want to do after each layout,\n     * i.e. size the container\n     */\n\n\n    Outlayer.prototype._postLayout = function () {\n      this.resizeContainer();\n    };\n\n    Outlayer.prototype.resizeContainer = function () {\n      if (!this.options.isResizingContainer) {\n        return;\n      }\n\n      var size = this._getContainerSize();\n\n      if (size) {\n        this._setContainerMeasure(size.width, true);\n\n        this._setContainerMeasure(size.height, false);\n      }\n    };\n    /**\n     * Sets width or height of container if returned\n     * @returns {Object} size\n     *   @param {Number} width\n     *   @param {Number} height\n     */\n\n\n    Outlayer.prototype._getContainerSize = noop;\n    /**\n     * @param {Number} measure - size of width or height\n     * @param {Boolean} isWidth\n     */\n\n    Outlayer.prototype._setContainerMeasure = function (measure, isWidth) {\n      if (measure === undefined) {\n        return;\n      }\n\n      var elemSize = this.size; // add padding and border width if border box\n\n      if (elemSize.isBorderBox) {\n        measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n      }\n\n      measure = Math.max(measure, 0);\n      this.element.style[isWidth ? 'width' : 'height'] = measure + 'px';\n    };\n    /**\n     * trigger a callback for a collection of items events\n     * @param {Array} items - Outlayer.Items\n     * @param {String} eventName\n     * @param {Function} callback\n     */\n\n\n    Outlayer.prototype._itemsOn = function (items, eventName, callback) {\n      var doneCount = 0;\n      var count = items.length; // event callback\n\n      var _this = this;\n\n      function tick() {\n        doneCount++;\n\n        if (doneCount === count) {\n          callback.call(_this);\n        }\n\n        return true; // bind once\n      } // bind callback\n\n\n      for (var i = 0, len = items.length; i < len; i++) {\n        var item = items[i];\n        item.on(eventName, tick);\n      }\n    }; // -------------------------- ignore & stamps -------------------------- //\n\n    /**\n     * keep item in collection, but do not lay it out\n     * ignored items do not get skipped in layout\n     * @param {Element} elem\n     */\n\n\n    Outlayer.prototype.ignore = function (elem) {\n      var item = this.getItem(elem);\n\n      if (item) {\n        item.isIgnored = true;\n      }\n    };\n    /**\n     * return item to layout collection\n     * @param {Element} elem\n     */\n\n\n    Outlayer.prototype.unignore = function (elem) {\n      var item = this.getItem(elem);\n\n      if (item) {\n        delete item.isIgnored;\n      }\n    };\n    /**\n     * adds elements to stamps\n     * @param {NodeList, Array, Element, or String} elems\n     */\n\n\n    Outlayer.prototype.stamp = function (elems) {\n      elems = this._find(elems);\n\n      if (!elems) {\n        return;\n      }\n\n      this.stamps = this.stamps.concat(elems); // ignore\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        var elem = elems[i];\n        this.ignore(elem);\n      }\n    };\n    /**\n     * removes elements to stamps\n     * @param {NodeList, Array, or Element} elems\n     */\n\n\n    Outlayer.prototype.unstamp = function (elems) {\n      elems = this._find(elems);\n\n      if (!elems) {\n        return;\n      }\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        var elem = elems[i]; // filter out removed stamp elements\n\n        removeFrom(elem, this.stamps);\n        this.unignore(elem);\n      }\n    };\n    /**\n     * finds child elements\n     * @param {NodeList, Array, Element, or String} elems\n     * @returns {Array} elems\n     */\n\n\n    Outlayer.prototype._find = function (elems) {\n      if (!elems) {\n        return;\n      } // if string, use argument as selector string\n\n\n      if (typeof elems === 'string') {\n        elems = this.element.querySelectorAll(elems);\n      }\n\n      elems = makeArray(elems);\n      return elems;\n    };\n\n    Outlayer.prototype._manageStamps = function () {\n      if (!this.stamps || !this.stamps.length) {\n        return;\n      }\n\n      this._getBoundingRect();\n\n      for (var i = 0, len = this.stamps.length; i < len; i++) {\n        var stamp = this.stamps[i];\n\n        this._manageStamp(stamp);\n      }\n    }; // update boundingLeft / Top\n\n\n    Outlayer.prototype._getBoundingRect = function () {\n      // get bounding rect for container element\n      var boundingRect = this.element.getBoundingClientRect();\n      var size = this.size;\n      this._boundingRect = {\n        left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n        top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n        right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n        bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n      };\n    };\n    /**\n     * @param {Element} stamp\n    **/\n\n\n    Outlayer.prototype._manageStamp = noop;\n    /**\n     * get x/y position of element relative to container element\n     * @param {Element} elem\n     * @returns {Object} offset - has left, top, right, bottom\n     */\n\n    Outlayer.prototype._getElementOffset = function (elem) {\n      var boundingRect = elem.getBoundingClientRect();\n      var thisRect = this._boundingRect;\n      var size = getSize(elem);\n      var offset = {\n        left: boundingRect.left - thisRect.left - size.marginLeft,\n        top: boundingRect.top - thisRect.top - size.marginTop,\n        right: thisRect.right - boundingRect.right - size.marginRight,\n        bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n      };\n      return offset;\n    }; // -------------------------- resize -------------------------- //\n    // enable event handlers for listeners\n    // i.e. resize -> onresize\n\n\n    Outlayer.prototype.handleEvent = function (event) {\n      var method = 'on' + event.type;\n\n      if (this[method]) {\n        this[method](event);\n      }\n    };\n    /**\n     * Bind layout to window resizing\n     */\n\n\n    Outlayer.prototype.bindResize = function () {\n      // bind just one listener\n      if (this.isResizeBound) {\n        return;\n      }\n\n      eventie.bind(window, 'resize', this);\n      this.isResizeBound = true;\n    };\n    /**\n     * Unbind layout to window resizing\n     */\n\n\n    Outlayer.prototype.unbindResize = function () {\n      if (this.isResizeBound) {\n        eventie.unbind(window, 'resize', this);\n      }\n\n      this.isResizeBound = false;\n    }; // original debounce by John Hann\n    // http://unscriptable.com/index.php/2009/03/20/debouncing-javascript-methods/\n    // this fires every resize\n\n\n    Outlayer.prototype.onresize = function () {\n      if (this.resizeTimeout) {\n        clearTimeout(this.resizeTimeout);\n      }\n\n      var _this = this;\n\n      function delayed() {\n        _this.resize();\n\n        delete _this.resizeTimeout;\n      }\n\n      this.resizeTimeout = setTimeout(delayed, 100);\n    }; // debounced, layout on resize\n\n\n    Outlayer.prototype.resize = function () {\n      // don't trigger if size did not change\n      // or if resize was unbound. See #9\n      if (!this.isResizeBound || !this.needsResizeLayout()) {\n        return;\n      }\n\n      this.layout();\n    };\n    /**\n     * check if layout is needed post layout\n     * @returns Boolean\n     */\n\n\n    Outlayer.prototype.needsResizeLayout = function () {\n      var size = getSize(this.element); // check that this.size and size are there\n      // IE8 triggers resize on body size change, so they might not be\n\n      var hasSizes = this.size && size;\n      return hasSizes && size.innerWidth !== this.size.innerWidth;\n    }; // -------------------------- methods -------------------------- //\n\n    /**\n     * add items to Outlayer instance\n     * @param {Array or NodeList or Element} elems\n     * @returns {Array} items - Outlayer.Items\n    **/\n\n\n    Outlayer.prototype.addItems = function (elems) {\n      var items = this._itemize(elems); // add items to collection\n\n\n      if (items.length) {\n        this.items = this.items.concat(items);\n      }\n\n      return items;\n    };\n    /**\n     * Layout newly-appended item elements\n     * @param {Array or NodeList or Element} elems\n     */\n\n\n    Outlayer.prototype.appended = function (elems) {\n      var items = this.addItems(elems);\n\n      if (!items.length) {\n        return;\n      } // layout and reveal just the new items\n\n\n      this.layoutItems(items, true);\n      this.reveal(items);\n    };\n    /**\n     * Layout prepended elements\n     * @param {Array or NodeList or Element} elems\n     */\n\n\n    Outlayer.prototype.prepended = function (elems) {\n      var items = this._itemize(elems);\n\n      if (!items.length) {\n        return;\n      } // add items to beginning of collection\n\n\n      var previousItems = this.items.slice(0);\n      this.items = items.concat(previousItems); // start new layout\n\n      this._resetLayout();\n\n      this._manageStamps(); // layout new stuff without transition\n\n\n      this.layoutItems(items, true);\n      this.reveal(items); // layout previous items\n\n      this.layoutItems(previousItems);\n    };\n    /**\n     * reveal a collection of items\n     * @param {Array of Outlayer.Items} items\n     */\n\n\n    Outlayer.prototype.reveal = function (items) {\n      var len = items && items.length;\n\n      if (!len) {\n        return;\n      }\n\n      for (var i = 0; i < len; i++) {\n        var item = items[i];\n        item.reveal();\n      }\n    };\n    /**\n     * hide a collection of items\n     * @param {Array of Outlayer.Items} items\n     */\n\n\n    Outlayer.prototype.hide = function (items) {\n      var len = items && items.length;\n\n      if (!len) {\n        return;\n      }\n\n      for (var i = 0; i < len; i++) {\n        var item = items[i];\n        item.hide();\n      }\n    };\n    /**\n     * get Outlayer.Item, given an Element\n     * @param {Element} elem\n     * @param {Function} callback\n     * @returns {Outlayer.Item} item\n     */\n\n\n    Outlayer.prototype.getItem = function (elem) {\n      // loop through items to get the one that matches\n      for (var i = 0, len = this.items.length; i < len; i++) {\n        var item = this.items[i];\n\n        if (item.element === elem) {\n          // return item\n          return item;\n        }\n      }\n    };\n    /**\n     * get collection of Outlayer.Items, given Elements\n     * @param {Array} elems\n     * @returns {Array} items - Outlayer.Items\n     */\n\n\n    Outlayer.prototype.getItems = function (elems) {\n      if (!elems || !elems.length) {\n        return;\n      }\n\n      var items = [];\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        var elem = elems[i];\n        var item = this.getItem(elem);\n\n        if (item) {\n          items.push(item);\n        }\n      }\n\n      return items;\n    };\n    /**\n     * remove element(s) from instance and DOM\n     * @param {Array or NodeList or Element} elems\n     */\n\n\n    Outlayer.prototype.remove = function (elems) {\n      elems = makeArray(elems);\n      var removeItems = this.getItems(elems); // bail if no items to remove\n\n      if (!removeItems || !removeItems.length) {\n        return;\n      }\n\n      this._itemsOn(removeItems, 'remove', function () {\n        this.emitEvent('removeComplete', [this, removeItems]);\n      });\n\n      for (var i = 0, len = removeItems.length; i < len; i++) {\n        var item = removeItems[i];\n        item.remove(); // remove item from collection\n\n        removeFrom(item, this.items);\n      }\n    }; // ----- destroy ----- //\n    // remove and disable Outlayer instance\n\n\n    Outlayer.prototype.destroy = function () {\n      // clean up dynamic styles\n      var style = this.element.style;\n      style.height = '';\n      style.position = '';\n      style.width = ''; // destroy items\n\n      for (var i = 0, len = this.items.length; i < len; i++) {\n        var item = this.items[i];\n        item.destroy();\n      }\n\n      this.unbindResize();\n      delete this.element.outlayerGUID; // remove data for jQuery\n\n      if (jQuery) {\n        jQuery.removeData(this.element, this.constructor.namespace);\n      }\n    }; // -------------------------- data -------------------------- //\n\n    /**\n     * get Outlayer instance from element\n     * @param {Element} elem\n     * @returns {Outlayer}\n     */\n\n\n    Outlayer.data = function (elem) {\n      var id = elem && elem.outlayerGUID;\n      return id && instances[id];\n    }; // -------------------------- create Outlayer class -------------------------- //\n\n    /**\n     * create a layout class\n     * @param {String} namespace\n     */\n\n\n    Outlayer.create = function (namespace, options) {\n      // sub-class Outlayer\n      function Layout() {\n        Outlayer.apply(this, arguments);\n      } // inherit Outlayer prototype, use Object.create if there\n\n\n      if (Object.create) {\n        Layout.prototype = Object.create(Outlayer.prototype);\n      } else {\n        extend(Layout.prototype, Outlayer.prototype);\n      } // set contructor, used for namespace and Item\n\n\n      Layout.prototype.constructor = Layout;\n      Layout.defaults = extend({}, Outlayer.defaults); // apply new options\n\n      extend(Layout.defaults, options); // keep prototype.settings for backwards compatibility (Packery v1.2.0)\n\n      Layout.prototype.settings = {};\n      Layout.namespace = namespace;\n      Layout.data = Outlayer.data; // sub-class Item\n\n      Layout.Item = function LayoutItem() {\n        Item.apply(this, arguments);\n      };\n\n      Layout.Item.prototype = new Item(); // -------------------------- declarative -------------------------- //\n\n      /**\n       * allow user to initialize Outlayer via .js-namespace class\n       * options are parsed from data-namespace-option attribute\n       */\n\n      docReady(function () {\n        var dashedNamespace = toDashed(namespace);\n        var elems = document.querySelectorAll('.js-' + dashedNamespace);\n        var dataAttr = 'data-' + dashedNamespace + '-options';\n\n        for (var i = 0, len = elems.length; i < len; i++) {\n          var elem = elems[i];\n          var attr = elem.getAttribute(dataAttr);\n          var options;\n\n          try {\n            options = attr && JSON.parse(attr);\n          } catch (error) {\n            // log error, do not initialize\n            if (console) {\n              console.error('Error parsing ' + dataAttr + ' on ' + elem.nodeName.toLowerCase() + (elem.id ? '#' + elem.id : '') + ': ' + error);\n            }\n\n            continue;\n          } // initialize\n\n\n          var instance = new Layout(elem, options); // make available via $().data('layoutname')\n\n          if (jQuery) {\n            jQuery.data(elem, namespace, instance);\n          }\n        }\n      }); // -------------------------- jQuery bridge -------------------------- //\n      // make into jQuery plugin\n\n      if (jQuery && jQuery.bridget) {\n        jQuery.bridget(namespace, Layout);\n      }\n\n      return Layout;\n    }; // ----- fin ----- //\n    // back in global\n\n\n    Outlayer.Item = Item;\n    return Outlayer;\n  } // -------------------------- transport -------------------------- //\n\n\n  if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = outlayerDefinition(require('eventie'), require('doc-ready'), require('eventemitter'), require('get-size'), require('matches-selector'), require('./item'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['eventie/eventie', 'doc-ready/doc-ready', 'eventEmitter/EventEmitter', 'get-size/get-size', 'matches-selector/matches-selector', './item'], outlayerDefinition);\n  } else {\n    // browser global\n    window.Outlayer = outlayerDefinition(window.eventie, window.docReady, window.EventEmitter, window.getSize, window.matchesSelector, window.Outlayer.Item);\n  }\n})(typeof window !== 'undefined' ? window : null);","map":null,"metadata":{},"sourceType":"script"}